{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About shuffle-kit","text":"<p>shuffle-kit is a Python package for modelling and analyzing playing card shuffles.</p> <p>It implements several mathematical models of commonly used shuffles that can be composed into complex sequences.</p> <p>In addition, several utility functions are provided to faciliate analyzing the various shuffle models.</p>"},{"location":"explanation/","title":"Explanations","text":"<p>Work in progress....</p>"},{"location":"how-to-guides/","title":"Guides","text":"<p>Work in progress....</p>"},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#create-and-use-your-first-model","title":"Create and use your first model","text":"<pre><code>from shuffl import make_sequence, Deck\n\ndeck = Deck([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"])\n\n# Alternatively you can pass models directly in a list, e.g.,\n# shuffle = make_sequence([riffle, strip, riffle, cut])\nshuffle = make_sequence(\"RSRC\") \n\nshuffled_deck = shuffle(deck)\n\nprint(f\"Before shuffle: {deck}\")\nprint(f\"After shuffle: {shuffled_deck}\")\n</code></pre>"},{"location":"getting-started/contributing/","title":"Contributing","text":"<p>shuffle-kit is a personal hobby project. However, I'm happy to accept contributions from others. </p> <ol> <li> <p>First clone the repository to a location of your choice  <pre><code>git clone https://github.com/jmssnr/shuffle-kit.git\n</code></pre></p> </li> <li> <p>Run <code>poetry install</code> to create a new virtual environment and install all dependencies, including dependencies for development and the documentation</p> </li> <li> <p>Run the tests to ensure everything is working properly <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<p>shuffle-kit requires Python 3.11+.</p> <p>To check if Python and pip are already installed on your machine you can run:</p> <pre><code>python --version\npip --version\n</code></pre>"},{"location":"getting-started/installation/#installing-into-an-existing-python-environment","title":"Installing into an existing Python environment","text":"<p>To install the latest stable version in your current Python environment, run:</p> <pre><code>pip install shuffle-kit\n</code></pre>"},{"location":"getting-started/installation/#installing-using-poetry","title":"Installing using Poetry","text":"<p>To install shuffle-kit into an existing Poetry project, run:</p> <pre><code>poetry add shuffle-kit\n</code></pre>"},{"location":"reference/core/","title":"Core","text":""},{"location":"reference/core/#shuffl","title":"<code>shuffl</code>","text":""},{"location":"reference/core/#shuffl.Deck","title":"<code>Deck</code>","text":"<p>             Bases: <code>list</code></p> <p>A list which only allows hashable and unique elements.</p> Source code in <code>shuffl/_deck.py</code> <pre><code>class Deck(list):\n    \"\"\"A list which only allows hashable and unique elements.\"\"\"\n\n    def __init__(self, iterable: Iterable) -&gt; None:\n        deck = _check_valid_iterable(iterable)\n        super().__init__(deck)\n\n    def insert(self, index: int, item: Hashable) -&gt; None:\n        _check_valid_item(item, self)\n        super().insert(index, item)\n\n    def append(self, item: Hashable) -&gt; None:\n        _check_valid_item(item, self)\n        super().append(item)\n</code></pre>"},{"location":"reference/core/#shuffl.Deck.__init__","title":"<code>__init__(iterable)</code>","text":"PARAMETER  DESCRIPTION <code>iterable</code> <p> TYPE: <code>Iterable</code> </p> Source code in <code>shuffl/_deck.py</code> <pre><code>def __init__(self, iterable: Iterable) -&gt; None:\n    deck = _check_valid_iterable(iterable)\n    super().__init__(deck)\n</code></pre>"},{"location":"reference/core/#shuffl.Deck.insert","title":"<code>insert(index, item)</code>","text":"PARAMETER  DESCRIPTION <code>index</code> <p> TYPE: <code>int</code> </p> <code>item</code> <p> TYPE: <code>Hashable</code> </p> Source code in <code>shuffl/_deck.py</code> <pre><code>def insert(self, index: int, item: Hashable) -&gt; None:\n    _check_valid_item(item, self)\n    super().insert(index, item)\n</code></pre>"},{"location":"reference/core/#shuffl.Deck.append","title":"<code>append(item)</code>","text":"PARAMETER  DESCRIPTION <code>item</code> <p> TYPE: <code>Hashable</code> </p> Source code in <code>shuffl/_deck.py</code> <pre><code>def append(self, item: Hashable) -&gt; None:\n    _check_valid_item(item, self)\n    super().append(item)\n</code></pre>"},{"location":"reference/evaluate/","title":"Evaluate","text":""},{"location":"reference/evaluate/#shuffl.evaluate","title":"<code>shuffl.evaluate</code>","text":"<p>This module provides different functions to evaluate shuffle models based on Monte-Carlo simulations.</p> <p>The implemented functions include:</p> <ul> <li><code>adjacent</code>: Returns average number of adjacent pairs in a permutation</li> <li><code>frequencies</code>: Returns empirical probabilities</li> <li><code>guess</code>: Returns average number of correct guesses of the top card </li> <li><code>risingseq</code>: Returns average number of rising sequences in a permutation</li> <li><code>solitaire</code>: Returns probability of Player A winning at the game New Age Solitaire</li> </ul>"},{"location":"reference/evaluate/#shuffl.evaluate.adjacent","title":"<code>adjacent(shuffle, num=1000)</code>","text":"<p>Returns average number of adjacent pairs.</p> <p>Adjacent pairs are pairs of cards that were together in the original deck and which are still together in the permutation.</p> <p>Example:</p> <pre><code>from shuffl.evaluate import adjacent\nfrom shuffl import Deck\n\n# Deck in original order\ndeck = Deck([\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n# Permutation of deck\npermutation = Deck([\"B\", \"C\", \"A\", \"D\", \"E\"])\n\n# Print adjacent pairs\n# [(\"B\", \"C\"), (\"D\", \"E\")]\nprint(adjacent(permutation, deck))\n</code></pre> PARAMETER  DESCRIPTION <code>shuffle</code> <p>A shuffle model</p> <p> TYPE: <code>Shuffle</code> </p> <code>num</code> <p>Number of Monte-Carlo simulations</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>list[list[float]]</code> <p>Discrete probability density function for every card</p> Source code in <code>shuffl/evaluate/_adjacent.py</code> <pre><code>def adjacent(\n    shuffle: Annotated[Shuffle, Doc(\"A shuffle model\")],\n    num: Annotated[int, Doc(\"Number of Monte-Carlo simulations\")] = 1000,\n) -&gt; Annotated[\n    list[list[float]], Doc(\"Discrete probability density function for every card\")\n]:\n    \"\"\"Returns average number of adjacent pairs.\n\n    Adjacent pairs are pairs of cards that were together in the original\n    deck and which are still together in the permutation.\n\n    **Example:**\n\n    ```python\n    from shuffl.evaluate import adjacent\n    from shuffl import Deck\n\n    # Deck in original order\n    deck = Deck([\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n    # Permutation of deck\n    permutation = Deck([\"B\", \"C\", \"A\", \"D\", \"E\"])\n\n    # Print adjacent pairs\n    # [(\"B\", \"C\"), (\"D\", \"E\")]\n    print(adjacent(permutation, deck))\n    ```\n    \"\"\"\n    deck = Deck(range(1, 53))\n\n    return np.mean([len(adjacent_pairs(shuffle(deck), deck)) for _ in range(num)])\n</code></pre>"},{"location":"reference/evaluate/#shuffl.evaluate.frequencies","title":"<code>frequencies(shuffle, num=1000)</code>","text":"<p>Computes the discrete probability density function resulting from applying the given shuffle to the given initial deck of cards via Monte-Carlo simulations.</p> <p>Example:</p> <pre><code>from shuffl.models import gsr, sequence\nfrom shuffl.evaluate import frequencies\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Creates a shuffle sequence of 6 riffle shuffles\n# following the Gilbert-Shannon-Reeds model\nshuffle = sequence([gsr]*6)\n\n# Compute the discrete probability density function\n# for all 52 cards via a Monte-Carlo simulation with\n# 10000 iterations\nproba = frequencies(shuffle, deck, 10000)\n\n# Print the results for the initial top card\nprint(proba[0])\n</code></pre> PARAMETER  DESCRIPTION <code>shuffle</code> <p>A shuffle model</p> <p> TYPE: <code>Shuffle</code> </p> <code>num</code> <p>Number of Monte-Carlo simulations</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>list[list[float]]</code> <p>Discrete probability density function for every card</p> Source code in <code>shuffl/evaluate/_frequencies.py</code> <pre><code>def frequencies(\n    shuffle: Annotated[Shuffle, Doc(\"A shuffle model\")],\n    num: Annotated[int, Doc(\"Number of Monte-Carlo simulations\")] = 1000,\n) -&gt; Annotated[\n    list[list[float]], Doc(\"Discrete probability density function for every card\")\n]:\n    \"\"\"Computes the discrete probability density function resulting\n    from applying the given shuffle to the given initial deck of cards via\n    Monte-Carlo simulations.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import gsr, sequence\n    from shuffl.evaluate import frequencies\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Creates a shuffle sequence of 6 riffle shuffles\n    # following the Gilbert-Shannon-Reeds model\n    shuffle = sequence([gsr]*6)\n\n    # Compute the discrete probability density function\n    # for all 52 cards via a Monte-Carlo simulation with\n    # 10000 iterations\n    proba = frequencies(shuffle, deck, 10000)\n\n    # Print the results for the initial top card\n    print(proba[0])\n    ```\n    \"\"\"\n    deck = Deck(range(1, 53))\n    samples = [shuffle(deck) for _ in range(0, num)]\n\n    return [\n        [sum([i == e.index(card) for e in samples]) / num for i in range(len(deck))]\n        for card in deck\n    ]\n</code></pre>"},{"location":"reference/evaluate/#shuffl.evaluate.solitaire","title":"<code>solitaire(shuffle, num=1000)</code>","text":"<p>Probability of Player A winning at the game New Age Solitaire determined via Monte-Carlo simulations.</p> <p>Example:</p> <pre><code>from shuffl.evaluate import solitaire\nfrom shuffl import Deck\nfrom shuffl.models import sequence, gsr\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Create a shuffle model\nshuffle = sequence([gsr]*10)\n\n# Evaluate the probability of player A\n# winning. For a well-mixed deck the expected\n# probability is 0.5\nprint(solitaire(shuffle, deck, 100000))\n</code></pre> PARAMETER  DESCRIPTION <code>shuffle</code> <p>A shuffle model</p> <p> TYPE: <code>Shuffle</code> </p> <code>num</code> <p>Number of Monte-Carlo simulations</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Probability of player A winning</p> Source code in <code>shuffl/evaluate/_solitaire.py</code> <pre><code>def solitaire(\n    shuffle: Annotated[Shuffle, Doc(\"A shuffle model\")],\n    num: Annotated[int, Doc(\"Number of Monte-Carlo simulations\")] = 1000,\n) -&gt; Annotated[float, Doc(\"Probability of player A winning\")]:\n    \"\"\"Probability of Player A winning at the game New Age Solitaire\n    determined via Monte-Carlo simulations.\n\n    **Example:**\n\n    ```python\n    from shuffl.evaluate import solitaire\n    from shuffl import Deck\n    from shuffl.models import sequence, gsr\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Create a shuffle model\n    shuffle = sequence([gsr]*10)\n\n    # Evaluate the probability of player A\n    # winning. For a well-mixed deck the expected\n    # probability is 0.5\n    print(solitaire(shuffle, deck, 100000))\n    ```\n    \"\"\"\n    deck = Deck(range(1, 53))\n    return np.mean([_round(deck, shuffle) for _ in range(num)])\n</code></pre>"},{"location":"reference/evaluate/#shuffl.evaluate.guess","title":"<code>guess(shuffle, num=1000)</code>","text":"<p>A guesser has to guess the top card of a face down shuffled deck of cards. After each guess the top card is revealed and then discared.</p> <p>The expected number of guesses is about 4.5 for a well-shuffled deck. The guessing game can thus be used to compare different shuffles.</p> <p>References:</p> <ul> <li>Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair. The Annals of Applied Probability, Vol. 2, No. 2, 294-313.</li> </ul> PARAMETER  DESCRIPTION <code>shuffle</code> <p>A shuffle model</p> <p> TYPE: <code>Shuffle</code> </p> <code>num</code> <p>Number of Monte-Carlo simulations</p> <p> TYPE: <code>int</code> DEFAULT: <code>1000</code> </p> RETURNS DESCRIPTION <code>float</code> <p>Average number of correct guesses</p> Source code in <code>shuffl/evaluate/_guessing.py</code> <pre><code>def guess(\n    shuffle: Annotated[Shuffle, Doc(\"A shuffle model\")],\n    num: Annotated[int, Doc(\"Number of Monte-Carlo simulations\")] = 1000,\n) -&gt; Annotated[float, Doc(\"Average number of correct guesses\")]:\n    \"\"\"A guesser has to guess the top card of a face down\n    shuffled deck of cards. After each guess the top card is revealed\n    and then discared.\n\n    The expected number of guesses is about 4.5 for a well-shuffled deck.\n    The guessing game can thus be used to compare different shuffles.\n\n    **References:**\n\n    - Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair.\n    The Annals of Applied Probability, Vol. 2, No. 2, 294-313.\n    \"\"\"\n    deck = Deck(range(1, 53))\n    return np.mean([_round(deck, shuffle) for _ in range(num)])\n</code></pre>"},{"location":"reference/models/","title":"Models","text":""},{"location":"reference/models/#shuffl.models","title":"<code>shuffl.models</code>","text":"<p>This module provides several different mathematical models for shuffling cards.</p> <p>The implemented models include:</p> <ul> <li><code>gsr</code>: Gilbert-Shannon-Reeds model for riffle shuffling</li> <li><code>thorp</code>: Thorp model for riffle shuffling</li> <li><code>strip</code>: Coin-toss model for strip or overhand shuffling</li> <li><code>cut</code>: Model for cutting a deck about in half</li> </ul>"},{"location":"reference/models/#shuffl.models.gsr","title":"<code>gsr(deck)</code>","text":"<p>Gilbert-Shannon-Reeds model for riffle shuffling.</p> <p>A deck of n cards is cut about in half according to a binomial distribution. The cards from the two packets are then riffled in such a way, that the probability of dropping a card from either half is proportional to the respective packet size.</p> <p>There are several analogous interpretations of the GSR model. This function implements the geometric interpretation.</p> <p>Example:</p> <pre><code>from shuffl.models import gsr\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Apply the shuffle\nshuffled_deck = gsr(deck)\n\n# Print the shuffled deck\nprint(shuffled_deck)\n</code></pre> <p>References:</p> <ul> <li>Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair. The Annals of Applied Probability, Vol. 2, No. 2, 294-313</li> </ul> PARAMETER  DESCRIPTION <code>deck</code> <p>A deck of cards</p> <p> TYPE: <code>Deck</code> </p> RETURNS DESCRIPTION <code>Deck</code> <p>The shuffled deck</p> Source code in <code>shuffl/models/_gsr.py</code> <pre><code>def gsr(\n    deck: Annotated[Deck, Doc(\"A deck of cards\")],\n) -&gt; Annotated[Deck, Doc(\"The shuffled deck\")]:\n    \"\"\"Gilbert-Shannon-Reeds model for riffle shuffling.\n\n    A deck of n cards is cut about in half according to a binomial\n    distribution. The cards from the two packets are then riffled in\n    such a way, that the probability of dropping a card from either\n    half is proportional to the respective packet size.\n\n    There are several analogous interpretations of the GSR model.\n    This function implements the geometric interpretation.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import gsr\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Apply the shuffle\n    shuffled_deck = gsr(deck)\n\n    # Print the shuffled deck\n    print(shuffled_deck)\n    ```\n\n    **References:**\n\n    - Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair.\n    The Annals of Applied Probability, Vol. 2, No. 2, 294-313\n    \"\"\"\n    x = np.sort(np.random.uniform(low=0, high=1, size=len(deck)))\n    y = 2 * x % 1\n    return Deck([deck[i] for i in np.argsort(y)])\n</code></pre>"},{"location":"reference/models/#shuffl.models.thorp","title":"<code>thorp(deck)</code>","text":"<p>Thorp model for riffle shuffling.</p> <p>The model cuts a deck of 2n cards into two packets of size n, and then starts dropping the cards from the left or right hand, such that each time one chooses the left or right card with probability 1/2 and then drops the card from the opposite hand.</p> <p>Example:</p> <pre><code>from shuffl.models import thorp\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Apply the shuffle\nshuffled_deck = thorp(deck)\n\n# Print the shuffled deck\nprint(shuffled_deck)\n</code></pre> <p>References:</p> <ul> <li>Thorp E. O. (1973). Nonrandom shuffling with applications to the game of Faro. Journal of the American Statistical Association, Vol. 68, No. 344, 842-847.</li> </ul> PARAMETER  DESCRIPTION <code>deck</code> <p>A deck of cards</p> <p> TYPE: <code>Deck</code> </p> RETURNS DESCRIPTION <code>Deck</code> <p>The shuffled deck</p> Source code in <code>shuffl/models/_thorp.py</code> <pre><code>def thorp(\n    deck: Annotated[Deck, Doc(\"A deck of cards\")],\n) -&gt; Annotated[Deck, Doc(\"The shuffled deck\")]:\n    \"\"\"Thorp model for riffle shuffling.\n\n    The model cuts a deck of _2n_ cards into two packets of size n, and\n    then starts dropping the cards from the left or right hand, such that\n    each time one chooses the left or right card with probability 1/2 and\n    then drops the card from the opposite hand.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import thorp\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Apply the shuffle\n    shuffled_deck = thorp(deck)\n\n    # Print the shuffled deck\n    print(shuffled_deck)\n    ```\n\n    **References:**\n\n    - Thorp E. O. (1973). Nonrandom shuffling with applications to the game of Faro.\n    Journal of the American Statistical Association, Vol. 68, No. 344, 842-847.\n    \"\"\"\n    n = int(len(deck) / 2)\n    cointoss = np.random.binomial(1, 0.5, n)\n    left, right = deck[:n], deck[n:]\n    shuffled = []\n    for c in cointoss:\n        if c == 0:\n            shuffled.extend([left.pop(0), right.pop(0)])\n        else:\n            shuffled.extend([right.pop(0), left.pop(0)])\n    return Deck(shuffled)\n</code></pre>"},{"location":"reference/models/#shuffl.models.strip","title":"<code>strip(deck)</code>","text":"<p>Coin toss model for strip cutting a deck of cards.</p> <p>The implementation is based on the coin toss interpretation of the strip shuffle.</p> <p>Example:</p> <pre><code>from shuffl.models import strip\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Apply the shuffle\nshuffled_deck = strip(deck)\n\n# Print the shuffled deck\nprint(shuffled_deck)\n</code></pre> PARAMETER  DESCRIPTION <code>deck</code> <p>A deck of cards</p> <p> TYPE: <code>Deck</code> </p> RETURNS DESCRIPTION <code>Deck</code> <p>The shuffled deck</p> Source code in <code>shuffl/models/_strip.py</code> <pre><code>def strip(\n    deck: Annotated[Deck, Doc(\"A deck of cards\")],\n) -&gt; Annotated[Deck, Doc(\"The shuffled deck\")]:\n    \"\"\"Coin toss model for strip cutting a deck of cards.\n\n    The implementation is based on the coin toss interpretation\n    of the strip shuffle.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import strip\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Apply the shuffle\n    shuffled_deck = strip(deck)\n\n    # Print the shuffled deck\n    print(shuffled_deck)\n    ```\n    \"\"\"\n    n = int(len(deck))\n    cointoss = np.random.binomial(1, 0.2, n - 1)\n    breakpoints = (np.flatnonzero(cointoss) + 1).tolist()\n    split_packets = np.split(deck, breakpoints)\n    return Deck([s for p in reversed(split_packets) for s in p])\n</code></pre>"},{"location":"reference/models/#shuffl.models.cut","title":"<code>cut(deck)</code>","text":"<p>Model for cutting a deck about in half and completing the cut.</p> <p>Cuts a given deck according to a binomial distribution.</p> <p>Example:</p> <pre><code>from shuffl.models import cut\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Apply the shuffle\nshuffled_deck = cut(deck)\n\n# Print the shuffled deck\nprint(shuffled_deck)\n</code></pre> <p>References:</p> <ul> <li>Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair. The Annals of Applied Probability, Vol. 2, No. 2, 294-313.</li> </ul> PARAMETER  DESCRIPTION <code>deck</code> <p>A deck of cards</p> <p> TYPE: <code>Deck</code> </p> RETURNS DESCRIPTION <code>Deck</code> <p>The shuffled deck</p> Source code in <code>shuffl/models/_cut.py</code> <pre><code>def cut(\n    deck: Annotated[Deck, Doc(\"A deck of cards\")],\n) -&gt; Annotated[Deck, Doc(\"The shuffled deck\")]:\n    \"\"\"Model for cutting a deck about in half and completing\n    the cut.\n\n    Cuts a given deck according to a binomial distribution.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import cut\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Apply the shuffle\n    shuffled_deck = cut(deck)\n\n    # Print the shuffled deck\n    print(shuffled_deck)\n    ```\n\n    **References:**\n\n    - Bayer D., Diaconis P. (1992). Trailing the dovetail shuffle to its lair.\n    The Annals of Applied Probability, Vol. 2, No. 2, 294-313.\n    \"\"\"\n    cut_point = np.random.binomial(len(deck), 0.5)\n    return Deck(deck[cut_point:] + deck[:cut_point])\n</code></pre>"},{"location":"reference/models/#shuffl.models.sequence","title":"<code>sequence(steps)</code>","text":"<p>Chains individual shuffles into a sequence of shuffles.</p> <p>Example:</p> <pre><code>from shuffl.models import gsr, strip, cut sequence\nfrom shuffl import Deck\n\n# Create a deck of 52 cards\ndeck = Deck(range(1,53))\n\n# Define riffle, riffle, strip, riffle, cut sequence\nshuffle = sequence([gsr, gsr, strip, gsr, cut])\n\n# Apply the shuffle\nshuffled_deck = shuffle(deck)\n\n# Print the shuffled deck\nprint(shuffled_deck)\n</code></pre> PARAMETER  DESCRIPTION <code>steps</code> <p>List of shuffle models</p> <p> TYPE: <code>list[Shuffle]</code> </p> RETURNS DESCRIPTION <code>Shuffle</code> <p>Sequence of composed shuffle models</p> Source code in <code>shuffl/models/_sequence.py</code> <pre><code>def sequence(\n    steps: Annotated[list[Shuffle], Doc(\"List of shuffle models\")],\n) -&gt; Annotated[Shuffle, Doc(\"Sequence of composed shuffle models\")]:\n    \"\"\"Chains individual shuffles into a sequence of shuffles.\n\n    **Example:**\n\n    ```python\n    from shuffl.models import gsr, strip, cut sequence\n    from shuffl import Deck\n\n    # Create a deck of 52 cards\n    deck = Deck(range(1,53))\n\n    # Define riffle, riffle, strip, riffle, cut sequence\n    shuffle = sequence([gsr, gsr, strip, gsr, cut])\n\n    # Apply the shuffle\n    shuffled_deck = shuffle(deck)\n\n    # Print the shuffled deck\n    print(shuffled_deck)\n    ```\n    \"\"\"\n\n    def shuffle(deck: Deck) -&gt; Deck:\n        for step in steps:\n            deck = step(deck)\n        return deck\n\n    return shuffle\n</code></pre>"},{"location":"reference/utilities/","title":"Utilities","text":""},{"location":"reference/utilities/#shuffl.utils","title":"<code>shuffl.utils</code>","text":"<p>This module provides different utility functions that facilitate working with and analyzing shuffle models.</p> <p>The implemented functions include:</p> <ul> <li><code>adjacent_pairs</code>: Returns number of adjacent pairs in a permutation </li> <li><code>sequences</code>: Returns all rising and descending sequences in a permutation</li> </ul>"},{"location":"reference/utilities/#shuffl.utils.adjacent_pairs","title":"<code>adjacent_pairs(permutation, original)</code>","text":"<p>Returns all adjacent pairs in a given permutation.</p> <p>Adjacent pairs are pairs of cards that were together in the original deck and which are still together in the permutation.</p> <p>Example:</p> <pre><code>from shuffl.utils import adjacent_pairs\nfrom shuffl import Deck\n\n# Deck in original order\ndeck = Deck([\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n# Permutation of deck\npermutation = Deck([\"B\", \"C\", \"A\", \"D\", \"E\"])\n\n# Print adjacent pairs\n# [(\"B\", \"C\"), (\"D\", \"E\")]\nprint(adjacent(permutation, deck))\n</code></pre> PARAMETER  DESCRIPTION <code>permutation</code> <p>A permutation of the original set</p> <p> TYPE: <code>Deck</code> </p> <code>original</code> <p>Original set</p> <p> TYPE: <code>Deck</code> </p> RETURNS DESCRIPTION <code>list[tuple]</code> <p>List of all adjacent pairs</p> Source code in <code>shuffl/utils/_adjacent_pairs.py</code> <pre><code>def adjacent_pairs(\n    permutation: Annotated[Deck, Doc(\"A permutation of the original set\")],\n    original: Annotated[Deck, Doc(\"Original set\")],\n) -&gt; Annotated[list[tuple], Doc(\"List of all adjacent pairs\")]:\n    \"\"\"Returns all adjacent pairs in a given permutation.\n\n    Adjacent pairs are pairs of cards that were together in the original\n    deck and which are still together in the permutation.\n\n    **Example:**\n\n    ```python\n    from shuffl.utils import adjacent_pairs\n    from shuffl import Deck\n\n    # Deck in original order\n    deck = Deck([\"A\", \"B\", \"C\", \"D\", \"E\"])\n\n    # Permutation of deck\n    permutation = Deck([\"B\", \"C\", \"A\", \"D\", \"E\"])\n\n    # Print adjacent pairs\n    # [(\"B\", \"C\"), (\"D\", \"E\")]\n    print(adjacent(permutation, deck))\n    ```\n    \"\"\"\n    permutation = _convert(permutation, original)\n    return [\n        (original[i], original[j]) for (i, j) in pairwise(permutation) if i + 1 == j\n    ]\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Work in progress....</p>"}]}